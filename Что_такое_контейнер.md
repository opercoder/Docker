## Что такое контейнеры
**(по мотивам книги "Безопасность контейнеров" Лиз Райс)**

**Контейнер** - это зона безопасности, за которую нельзя выходить.  
Приложения выполняются в пользовательском пространстве (userspace). При обращении к файлам, получении текущего времени, передачи данных по сети **требуется обращение к ядру**, поскольку не хватает обычных полномочий не хватает.  
Интерефейс, позволяющий это сделать, называется **интерфейс системных вызовов (systemcall)**.  
Существует более 300 системных вызовов: _open, write, read, execute, chown, clone и др_.  
Все контейнеры работают с одним и тем же ядром, но не всем нужны одникаовые полномочия. Поэтому их надо выдавать минимум.  
#### DAC  
**Discretionary access control** - избирательно право управления доступом.  
-rwx,rw-,rw- (пользователь,группа,прочие).  
Также существуют биты _setuid, setgid, sticky_.  
#### setuid  
**# _chmod +s_**  
При установленном бите запущенный процесс наследует права его владельца. Например, **ping**.  
Ping может запускать любой пользователь, при этом для его работы нужны права, которых нет у обычного пользователя.  
Ping в итоге работает, сбрасывая права root. Можно проверить командой: **strace -f -p <pid>**.  
Проследуют setcap (системные вызовы), потом setuid для смены пользователя.  
ВАЖНО: если программа выставит себе _setuid_, станет _root_, то из под _root_ сможет запустить командную оболочку.  
Docker может запрещать файлы с битом _setuid_ (docker run --no-new-privileges).  
#### Привилегии Linux  
Существует более 30 привилегий. Например, привязка к порту с номером меньше 1024: CPA_NET_BIND_SERVICE.  
CAP_NET_RAW - открытие сокета прямого доступа (необходима для ping).  
**# _getpcaps <pid>_** - посмотреть список доступных привилегий;  
**# _setcap 'cap_net_raw+p' ./myping_** - дать необходимые привилегии файлу;  
**# _getcap <filename>_** - посмотреть.  
#### Контрольные группы (cgroups)  
Нужны для ограничения группе процессов ресурсов: процессорных ресурсов, оперативной памяти и др.  
Существует контрольная группа _pid_ для ограничения количества процессов в контрольной группе (защита от атаки fork, когда процесс порождает процессы и т.д.).  
Любой процесс является членом одной контрольной группы  для каждого типа ресурсов. Дочерний процесс попадает в _cgroup_ родительского.  
Все группы лежат в **/sys/fs/cgroup  
\# _mkdir /sys/fs/cgroup/memory/testgroup_** - создание контрольной группы.  
Ядро автоматически заполнит каталог файлами параметров и статистики этой группы. Внутри контейнера можно увидеть такие же контрольные группы в каталоге: /proc/$$/cgroup.  
Ограничение по памяти для процесса:  
**# _echo 100000 > /sys/fs/cgroup/memory/testgroup/memory.limit_in_bytes_**  
**# _echo \<pid\> > /sys/fs/cgroup/memory/testgroup/cgroup.procs_**  
Docker создает контрольные группы для всех ресурсов.  
## Изоляция контейнеров  
На первый взгляд у контейнеров своя файловая система, независисмая от хост компьютера. Команда _ps_ отображает только процессы контейнера, свой сетевой стек. Но на самом деле это не виртуальная машина по степени изоляции.  
### 1. Пространство имен (Namespace)  
Cgroups позволяют контролировать ресурсы, доступные процессу, а namespace позволяет ограничить видимые ресурсы.  
Виды:  
1. UTS.  
1. Идентификаторы процессов (PID).  
1. Точки монтирования.  
1. Сеть.  
1. Идентификаторы пользователей и групп.  
1. Обмен информацией между процессами (IPC).  
1. Контрольные группы.  
Процесс всегда относится ровно к одному пространству имен каждого вида.  
**# _lsns_** - посмотреть пространства имен.  
1. **UTS**  
Команда **hostname** внутри контейнера выдает случайное другое имя, нежели хост.  
\>  sudo unshare --uts sh (unshare - создает дочерний процесс, но в собственном namespace)  
\> hostname test  
\> exit  
\> hostname - выведет настоящее имя хоста  
1. **PID**  
\> sudo unshare --pid --fork sh  
Но при этом _ps -eaf_ все еще выдает все процессы... Почему?  
PS читает файлы в /proc. А там много интересного, например, /proc/\<pid\>/exe - символическая ссылка выполняющегося файла в рамках процесса.  
Следовательно, нужна копия /proc, но в рамках пространства имен. Значит необходимо изменение корневого каталога.  
1. **Изменение корневого каталога (Chroot)**  
Корневой каталог процесса начинает указывать на другую точку файловой системы. Chroot не только меняет каталог, но и выполняет заданную команду. Если та не указана, то запускает командную оболочку.  
Если сделать chroot \<new_dir\>, то система выдаст ошибку, поскольку не найдет /bin/sh.  
Следовательно, нужен минимальный образ файловой системы (например, alpine), распаковать его и сделать chroot в него. Chroot отработает без ошибок.  
По таком принципу и работают контейнеры. В контейнерах обычно используется системный вызов pivot-root (он безопаснее). Он не только меняет корневой каталог, но еще и размонтирует старый корневой каталог и монтирует новый.  
Использует пространство имен точек монтирования.  
\> sudo unshare --pid --fork chroot alpine sh  
\> mount -t proc proc proc  
\> ps - теперь видит только свои процессы.  
\> sudo unshare --mount sh  
\> mount --bind source target  
\> findmnt target - покажет точки монтирования.  
При этом из хоста она будет не видна. Но внутри namespace _findmnt_ отобразит все точки монтирования (хоста). Следовательно, надо изолировать.  
\> sudo unshare --mount chroot alpine sh  
\> mount -t proc proc proc  
\> mount --bind source target  
\> mount - так же как и _findmnt_ отобразит только процессные точки монтирования.  
1. **Сеть  
\# lsns -t net**  
\> sudo unshare --net bash - помещает процесс в отдельное пространство имен  
\> ip a - отобразит только loopback  
ip link add ve1 netns 28564 type veth peer name ve2 netns1 (netns 28564 - namespace with pid 28564)  
ip link set ve1 up + ip add...  
ip link set ve2 up + ip add...  
Создастся виртуальное соединение между контейнером и хостом. Можно делать ping.  
1. **Пространство имен пользователей**  
Можно связать уперпользователя в контейнере с обычным пользователем на хосте.  
ВАЖНО: возможно до сих пор не работает в Docker и Kubernetes.  
\> unshare --user bash  
\> id  
uid=65534(nobody), gid=..., groups=...  
Теперь привяжем пользователя в /proc/\<pid\>/uid_map: _sudo echo '0 1000 1' > /proc/\<pid\>/uid_map_.  
_0_ - идентификатор root,  
_1000_ - идентификатор пользователя на хосте,  
_1_ - количество пользователей для привязки внутри контейнера.  
\> id  
uid=0(root)  
Т.е. изначально создается пространство имен пользователей. Следовательно, непривилегированный пользователь может создавать контейнеры с правами root.  
1. **Пространство имен обмена информацией между процессами (IPC)**  
\# ipcmk -M 1000 - создает разделяесый блок памяти.  
\# ipcs - просмотр текущего состояния IPC.  
1. **Пространство имен контрольных групп**
Аналогично chroot.  cat /proc/self/cgroup сравнить с cat /proc/self/group после unshare --cgroup bash.  
### Резюме  
Правильнее контейнеры называть контейнеризированными процессами, т.е. ограниченными с помощью namespaces, cgroup, chroot. А поскольку это всего лишь процесс, то работает в контексте того же ядра.  
ВАЖНО: Процессы контейнеров видны с хоста. Злоумышленник, получив доступ к хосту, сможет все контроллировать.  
Необходимо минимизировать возможность взлома хоста. Рекомендуется использовать хост только для контейнеров (реальная машина или виртуальная).  
Учетных записей должно быть минимум для облегчения контроля.  
Использовать упрощенные ОС: Rancher OS, FedoreCore OS, Photon OS.  
Все хосты должны иметь одинаковую конфигурацию.  
Журналирование и оповещение о входах и попытках входа в хост.  
cisecurity.org - сайт с оценками эффективности и практическами рекомендациями по настройке Docker, k8s.  
